package com.nexters.jung2.daemon.sentence;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.log4j.Logger;

import kr.co.shineware.nlp.komoran.core.MorphologyAnalyzer;
import kr.co.shineware.util.common.model.Pair;

public class ConvertThread implements Runnable {
	private static Logger logger = Logger.getLogger(ConvertThread.class.getName());
	
	private int intSpacing = 0;
	private int intAddWords = 0;
	
	private static MorphologyAnalyzer analyzer = new MorphologyAnalyzer("/usr/jboss/jboss-6.1.0.Final/server/jung2/deploy/ROOT.war/WEB-INF/datas/");
	private static String jdbcDriver = "org.postgresql.Driver";
	private static String jdbcUrl = "jdbc:postgresql://localhost:5432/jung2";
	private static String jdbcId = "jung2";
	private static String jdbcPw = "jung2qwer1234";
	private static String strSql = "SELECT NO, CATE, BEFOREMSG FROM JW_PROCMSG WHERE AFTERMSG IS NULL";
	private static String strSql1 = "SELECT CONTENTS, TYPE1, TYPE2, TYPE3, TYPE4 FROM JW_WORDS "
									+ "WHERE MP = ? AND CATEGORY = ? AND (TYPE1 = 'T' OR TYPE2 = 'T') "
									+ "ORDER BY random() LIMIT 10";
	private static String strSql2 = "UPDATE jw_procmsg SET aftermsg=? WHERE NO = ?";
	
	/* Connection Pool 구현 전까지 static으로한다. */
	private static Connection conn = null;
	
	@Override
	public void run() {
		logger.info(this.getClass().getName() + "를 시작합니다.");
		
		while(true) {
			String strCate = "";
			String strNo = "";
			String strOriginMsg = "";
			String strAfterMsg = "";

			
			PreparedStatement pstm = null;
			ResultSet rs = null;
			
			PreparedStatement pstm1 = null;
			ResultSet rs1 = null;
			
			PreparedStatement pstm2 = null;

			
			try {
				Class.forName(jdbcDriver);
				conn = DriverManager.getConnection(jdbcUrl, jdbcId, jdbcPw);

				pstm = conn.prepareStatement(strSql);
		    	rs = pstm.executeQuery();
		    	
				while(rs.next()) {
					strOriginMsg = rs.getString("BEFOREMSG");
					strCate = rs.getString("CATE");
					strNo	= rs.getString("NO");
					long start = System.currentTimeMillis(); 
					logger.info("#####################################################");
					logger.info("start::"+start+",strOriginMsg::"+strOriginMsg+",strCate::"+strCate+",strNo::"+strNo);
					ArrayList<String> arrayMM = new ArrayList<String>();
					ArrayList<String> arrayMA = new ArrayList<String>();
					ArrayList<String> arrayEC = new ArrayList<String>();
					
					ArrayList<Jung2Conf> arrayJung2 = new ArrayList<Jung2Conf>();
					HashMap<String, ArrayList<Jung2Conf>> mapJung2 = new HashMap<String, ArrayList<Jung2Conf>>();
					HashMap<String, ArrayList<String>> mapSentence = new HashMap<String, ArrayList<String>>();
					
					 List<List<Pair<String,String>>> result = analyzer.analyze(strOriginMsg);
				        
				        for (List<Pair<String, String>> eojeolResult : result) {
				        	intSpacing++;
				        	
					        for (Pair<String, String> wordMorph : eojeolResult) {
					        	if(intAddWords<intSpacing) {
					        		intAddWords++;
					        		
						        	String strWordSecond = wordMorph.getSecond();
						        	String strWordFirst = wordMorph.getFirst();
						        	
						        	logger.debug(strWordSecond+"::"+strWordFirst);
						        	if((strWordSecond.indexOf("NN") > -1 ) || (strWordSecond.equals("NP")) || (strWordSecond.equals("NR"))) {
						        		arrayMM.add(strWordFirst);
						        	} else if (strWordSecond.equals("VV") || strWordSecond.equals("VA")) {
						        		arrayMA.add(strWordFirst);
						        	} else if (strWordSecond.equals("EC")) {
						        		arrayEC.add(strWordFirst);   		
						        	}
					        	}
					        }
				        }
				        logger.debug("arrayMM::"+arrayMM.toString());
				        logger.debug("arrayMA::"+arrayMA.toString());
				        logger.debug("arrayEC::"+arrayEC.toString());

				        pstm1 = conn.prepareStatement(strSql1);
				        pstm1.setString(1, "MM");
				        pstm1.setString(2, strCate);
				        rs1 = pstm1.executeQuery();

			        	while(rs1.next()) {
			        		HashMap<String, String> mapAvailableWords = new HashMap<String, String>();
			        		
			        		mapAvailableWords.put("type1", rs1.getString("type1"));
			        		mapAvailableWords.put("type2", rs1.getString("type2"));
			        		mapAvailableWords.put("type3", rs1.getString("type3"));
			        		mapAvailableWords.put("type4", rs1.getString("type4"));
			        		logger.debug("contetns::"+rs1.getString("contents"));
			        		logger.debug("mapAvailableWords::"+mapAvailableWords.toString());
			        		Jung2Conf jun2conf = new Jung2Conf(rs1.getString("contents"), mapAvailableWords);
			        		arrayJung2.add(jun2conf);
			        	}
			        	mapJung2.put("MM", arrayJung2);
			        	
			        	logger.debug("mapJung2::"+mapJung2.toString());
			        	
			        	mapSentence.put("MM", arrayMM);
			        	mapSentence.put("MA", arrayMA);
			        	mapSentence.put("EC", arrayEC);
			        	
			        	SentenceConf senconf = new SentenceConf(strOriginMsg, mapSentence);
			        	MerSen cmersen = new MerSen();
			        	strAfterMsg = cmersen.mergeSentence(senconf, mapJung2);
			        	
			        	pstm2 = conn.prepareStatement(strSql2);
			        	pstm2.setString(1, strAfterMsg);
			        	pstm2.setString(2, strNo);
			        	pstm2.executeUpdate();
			        	
						long end = System.currentTimeMillis(); 
						logger.info("소요시간::"+(end-start));

				}
			} catch(Exception e) {
				logger.error("오류가 발생하였습니다. ::", e);
	        } finally {
	        	try { if(rs!=null) rs.close(); } catch (Exception e) {}
	        	try { if(rs1!=null) rs1.close(); } catch (Exception e) {}
				try { if(pstm!=null) pstm.close(); } catch (Exception e) {}
				try { if(pstm1!=null) pstm1.close(); } catch (Exception e) {}
				try { if(pstm2!=null) pstm2.close(); } catch (Exception e) {}
	            try { if(conn!=null) conn.close(); } catch (Exception e) {}
	        }
			
			try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				logger.error("오류가 발생하였습니다. ::", e);
			}

		}		
	}

}
